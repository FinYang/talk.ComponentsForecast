---
title: "Component-based Approach in Multivariate and Hierarchical Forecasting"
author: [
    "Yangzhuoran Fin Yang",
    "Rob J Hyndman",
    "George Athanasopoulos",
    "Anastasios Panagiotelis"
]
template: template.tex
keep-tex: true
bibliography: ["refs.bib"]
format: 
  beamer: 
    pdf-engine: pdflatex
    cite-method: natbib
    biblio-title: "References"
    theme: monash
    fonttheme: monash
    colortheme: monashwhite
header-includes:
  - \usepackage{bm}
  - \usepackage[makeroom]{cancel}
  - \widowpenalties 1 150
  - \newlength{\cslhangindent}
  - \setlength{\cslhangindent}{1.5em}
  - \newenvironment{CSLReferences}[2]{\everypar{\setlength{\hangindent}{\cslhangindent}}\ignorespaces}{}
titlefontsize: 18
---

## What people do
```{r}
# ï½œ include: false
library(RANN)
library(ggrepel)
library(igraph)
library(tidyverse)
library(ggforce)
library(gridExtra)
library(hts)
library(fpp2)
library(tsibble)
library(feasts)
library(ggarchery)
library(ggrepel)
```


```{r}
#| include: false
length <- 4
ratio <- 6 / 3
y_top <- 4
y_bottom <- 0
x_left <- 0
x_right <- 8


rect <- tribble(
  ~x, ~y, ~text, ~colour,
  x_left, y_top, "Multivariate \n Data", "#aee5ea",
  x_right, y_top, "Forecasts \n (Data)", "#aee5ea",
  x_left, y_bottom, "Components", "#ffe1a3",
  x_right, y_bottom, "Forecasts \n (Components)", "#ffe1a3"
) %>%
  mutate(
    xmin = x - length / 2,
    xmax = x + length / 2,
    ymin = y - length / ratio / 2,
    ymax = y + length / ratio / 2
  )

lines_h <- tribble(
  ~x, ~y, ~xend, ~yend, ~colour,
  x_left + length / 2, y_top, x_right - length / 2, y_top, "#b3e6de",
  x_left + length / 2, y_bottom, x_right - length / 2, y_bottom, "#f7f0b7"
)
lines_v <- tribble(
  ~x, ~y, ~xend, ~yend,
  x_left, y_top - length / ratio / 2, x_left, y_bottom + length / ratio / 2,
  x_right, y_bottom + length / ratio / 2, x_right, y_top - length / ratio / 2,
)

texts_h <- tribble(
  ~x, ~y, ~text,
  (x_left + x_right) / 2, y_top, "Forecast Model",
  (x_left + x_right) / 2, y_bottom, "Forecast Model",
)
texts_v <- tribble(
  ~x, ~y, ~text,
  x_left - length / ratio / 2 / 2, (y_top + y_bottom) / 2 * 1.1, "PCA, etc",
  x_right + length / ratio / 2 / 3 * (-0.2), (y_top + y_bottom) / 2 / 1.1, "Back-transformation",
)

index_step <- tribble(
  ~x, ~y, ~text,
  x_left - length / ratio / 2 / 2, (y_top + y_bottom) / 2 / 1.2, "1",
  (x_left + x_right) / 2, y_bottom + 0.5, "2",
  x_right + length / ratio / 2 / 2, (y_top + y_bottom) / 2 * 1.2, "3",
)

p_ours <- ggplot() +
  theme_void() +
  geom_rect(
    data = rect,
    aes(xmin = xmin, ymin = ymin, xmax = xmax, ymax = ymax, fill = colour)
  ) +
  geom_text(
    data = rect,
    aes(x = x, y = y, label = text),
    size = 8
  ) +
  geom_segment(
    data = lines_h,
    aes(x = x - 0.02, y = y, xend = xend, yend = yend),
    linewidth = 17,
    arrow = arrow(length = unit(5, "mm"), type = "closed"),
    position = position_attractsegment(
      start_shave = 0.12, end_shave = 0.8, type_shave = "distance"
    ),
    linejoin = "mitre",
    lineend = "butt"
  ) +
  geom_segment(
    data = lines_h,
    aes(x = x, y = y, xend = xend, yend = yend, colour = colour),
    linewidth = 16,
    arrow = arrow(length = unit(5, "mm"), type = "closed"),
    position = position_attractsegment(
      start_shave = 0.12, end_shave = 0.8, type_shave = "distance"
    ),
    linejoin = "mitre",
    lineend = "butt"
  ) +
  geom_text(
    data = texts_h,
    aes(x = x, y = y, label = text),
    size = 6
  ) +
  geom_segment(
    data = lines_v,
    aes(x = x, y = y, xend = xend, yend = yend),
    linewidth = 2,
    arrow = arrow(length = unit(5, "mm"), type = "closed"),
    position = position_attractsegment(
      start_shave = 0.12, end_shave = 0.12, type_shave = "distance"
    ),
    linejoin = "mitre",
    lineend = "butt",
    colour = "black"
  ) +
  geom_label(
    data = texts_v,
    aes(x = x, y = y, label = text),
    size = 7,
    label.padding = unit(0.6, "lines"),
    fill = "#f7f0b7"
  ) +
  geom_label(
    data = index_step,
    aes(x = x, y = y, label = text),
    size = 8,
    label.padding = unit(0.6, "lines")
  ) +
  # lims(
  #   x = c(min(rect$xmin)-1, max(rect$xmax) + 1),
  #   y = c(min(rect$ymin)-1, max(rect$ymax) + 1)
  # ) +
  scale_fill_identity() +
  scale_colour_identity()
ggsave("plot/p_ours.pdf", p_ours, height = unit(6, "cm"), 
       width = unit(9, "cm"))

p_others <- p_ours +
  geom_rect(
    aes(
      xmin = min(rect$xmin), xmax = max(rect$xmax),
      ymin = min(rect$ymin), ymax = max(rect$ymin)
    ),
    colour = "#FAFAFA",
    fill = "#FAFAFA"
  )
ggsave("plot/p_others.pdf", p_others, height = unit(6, "cm"), 
       width = unit(9, "cm"))
```

\includegraphics[width=\linewidth]{plot/p_others}

## What we do


\includegraphics[width=\linewidth]{plot/p_ours}

## Australian tourism data


```{r}
#| label: fig-Austour
#| include: false
#| fig.cap: "Top: Total domestic travel in Australia. Bottom: Domestic travel in the region of Central NSW."
#| out.width: "80%"

# visnights <- qs::qread("pieces/progress_review/data/visnights.qs")
visnights <- qs::qread("data/visnights.qs")
p_aus_mel <- bind_rows(
  visnights %>% 
    summarise(Nights = sum(Nights)) %>% 
    as_tibble() %>% 
    mutate(Region = "Australia"),
  visnights %>% 
    filter(Region == "Melbourne") %>% 
    as_tibble() 
) %>% 
  ggplot() +
  geom_line(aes(x = Month, y = Nights)) +
  facet_grid("Region", scales = "free") +
  scale_y_log10()  +
  theme(plot.background = element_rect(fill = "#FAFAFA", colour = "#FAFAFA"))
p_syd_mel <- visnights %>% 
  filter(Region %in% c("Sydney", "Melbourne")) %>% 
  group_by(Region) %>% 
  summarise(Nights = sum(Nights), .groups = "drop") %>% 
  as_tibble() %>% 
  ggplot() +
  geom_line(aes(x = Month, y = Nights, colour = Region)) +
  # facet_grid("Region", scales = "free") +
  scale_y_log10()  +
  theme(plot.background = element_rect(fill = "#FAFAFA", colour = "#FAFAFA"), 
        legend.background = element_rect(fill = "#FAFAFA", colour = "#FAFAFA"),
        legend.position = "bottom")

ggsave("plot/p_syd_mel.pdf", p_syd_mel,
        height = unit(4, "cm"), 
       width = unit(6, "cm")
)
ggsave("plot/p_aus_mel.pdf", p_aus_mel,
        height = unit(4, "cm"),
       width = unit(6, "cm")
)

# Sys.getlocale()
```

* Australia comprises seven states and territories which can be divided into 76 regions
  - For example, Melbourne, Sydney, East Coast

### Visitor nights
The total number of nights spent by Australians away from home recorded monthly


## Total and Region

\begin{center}
\includegraphics[width=\linewidth]{plot/p_aus_mel}
\end{center}



## Melbourne and Sydney

\begin{center}
\includegraphics[width=\linewidth]{plot/p_syd_mel}
\end{center}

## Intuition
\begin{block}{Observation}

1. Better signal-noise ratio in the linear combination.

\pause
2. Similar patterns are shared in different series.
\end{block}

\pause

\begin{alertblock}{One step further}
Finding components that have better signal-noise ratio:


1. Easy to forecast;

2. Capturing the common signals;

3. Improving forecast of original series.
\end{alertblock}

## Literature

### Factor model [@Bai2008-of]

1. Linear transformation
1. VAR models

### Dynamic Factor Machine Learning [DFML, @DeStefani2021-nt]

1. Nonlinear transformations with an inherent two-way mapping
    - Autoencoder
1. Machine learning forecast methods

## Our differences

1. Allowing nonlinear transformations
1. Allowing transformations without an inverse function
1. Mappings between forecasts of the components and forecasts of the original series
1. Arbitrary forecast models

## Overview

\includegraphics[width=\linewidth]{plot/p_ours}

## Overview


```{r}
#| include: false
y_top <- 1
y_bottom <- 0
x_start <- 0
x_now <- 5
tick_h <- 0.02
tick_gap <- 0.5
x_future <- 6

timeline <- tribble(
  ~x, ~xend, ~y, ~yend, ~label,
  x_start, x_now, y_top, y_top, "horizontal_top",
  x_start, x_now, y_bottom, y_bottom, "horizontal_bottom",
  seq(x_start, x_future, by = tick_gap),
  seq(x_start, x_future, by = tick_gap),
  y_top + tick_h,
  y_top, "tick_top",
  seq(x_start, x_future, by = tick_gap),
  seq(x_start, x_future, by = tick_gap),
  y_bottom + tick_h,
  y_bottom, "tick_bottom",
  x_now, x_future, y_top, y_top, "future_top",
  x_now, x_future, y_bottom, y_bottom, "future_bottom",
  x_now, x_now, y_top + 2 * tick_h, y_top, "tick_big",
  x_now, x_now, y_bottom + 2 * tick_h, y_bottom, "tick_big",
  x_start, x_start, y_top + 2 * tick_h, y_top, "tick_big",
  x_start, x_start, y_bottom + 2 * tick_h, y_bottom, "tick_big",
  x_future, x_future, y_top + 2 * tick_h, y_top, "tick_big",
  x_future, x_future, y_bottom + 2 * tick_h, y_bottom, "tick_big",
) %>%
  unnest(cols = c(x, xend, y, yend)) %>%
  mutate(linetype = ifelse(grepl("future", label), "dashed", "solid"))

text <- tribble(
  ~x, ~y, ~text,
  x_start, y_top, "Multivariate Series",
  x_start, y_bottom, "Components",
)
label <- tribble(
  ~x, ~y, ~text,
  (x_start + x_now) / 2, (y_top + y_bottom) / 2, "1. Extract Components",
  (x_now + x_future) / 2, y_bottom - 0.4, "2. Forecast Component",
  x_future*0.98, (y_top + y_bottom) / 2, "3. Back-transform"
)
tick_label <- tribble(
  ~x, ~text,
  x_start, "0",
  x_now, "T",
  x_future, "T+h",
  x_start + (1:3) * tick_gap, c(1, 2, "...")
) %>%
  unnest(everything()) %>%
  mutate(y_top, y_bottom) %>%
  pivot_longer(starts_with("y"), values_to = "y")

arrow1 <- tribble(
  ~x, ~y, ~xend, ~yend,
  (x_start + x_now) / 2, y_top, (x_start + x_now) / 2, y_bottom,
)
arrow2 <- tribble(
  ~x, ~y, ~xend, ~yend,
  x_now, y_bottom, x_future, y_bottom,
)
arrow3 <- tribble(
  ~x, ~y, ~xend, ~yend,
  x_future, y_bottom, x_future, y_top
)

p_timeline <- ggplot(size = 8) +
  geom_segment(aes(x = x, xend = xend, y = y, yend = yend, linetype = linetype),
               data = timeline
  ) +
  geom_segment(
    aes(x = x, y = y, xend = xend, yend = yend),
    data = arrow1,
    # linewidth = 1,
    arrow = arrow(length = unit(3, "mm")),
    position = position_attractsegment(
      start_shave = 0.12, end_shave = 0.12, type_shave = "distance"
    ),
    linejoin = "mitre",
    lineend = "butt"
  ) +
  geom_curve(
    aes(x = x, y = y - 0.15, xend = xend, yend = yend - 0.15),
    data = arrow2,
    # linewidth = 1,
    arrow = arrow(length = unit(3, "mm")),
    # position = position_attractsegment(
    #   start_shave = 0.12, end_shave = 0.12, type_shave = "distance"),
    # position = "nudge",
  ) +
  geom_segment(
    aes(x = x, y = y, xend = xend, yend = yend),
    data = arrow3,
    # linewidth = 1,
    arrow = arrow(length = unit(3, "mm")),
    position = position_attractsegment(
      start_shave = 0.12, end_shave = 0.12, type_shave = "distance"
    ),
    linejoin = "mitre",
    lineend = "butt"
  ) +
  geom_text(aes(x = x, y = y, label = text), data = text, vjust = -2, hjust = "left") +
  geom_label(aes(x = x, y = y, label = text), data = label) +
  geom_text(aes(x = x, y = y, label = text), data = tick_label, vjust = 1.5) +
  theme_void() +
  lims(
    y = c(-0.5, 1.2),
    x = c(-0.1, 6.3)
  ) +
  # coord_cartesian(clip = "off") +
  scale_linetype_identity()
p_timeline
ggsave("plot/p_timeline.pdf", p_timeline,
       height = unit(6 / 1.4, "cm"),
       width = unit(10 / 1.4, "cm")
)
```

\begin{center}
\includegraphics[width=\linewidth]{plot/p_timeline}
\end{center}

## 1. Components: Linear

Taking the first $q$ linear combinations
$$\underset{T\times k}{\bm{Y}}\underset{k\times q}{\bm{W}}=\underset{T\times q}{\bm{C}},$$
where $\bm{C}$ is the first $q$ components, $\bm{W}$ is the weighting matrix.


---

### Principal Component Analysis (PCA)

Finding the weights matrix so that the resulting components \alert{\textbf{maximise variance}}:
$$\begin{aligned}
\widehat{\bm{w}}_{s}=& \underset{\bm{w} \in \mathbb{R}^{k}}{\text{argmax} } ||\bm{Y}\bm{w}||_2, \quad s=1, \ldots, q \\
\text { subject to } \bm{Y}\bm{w}_{s}  & \perp\left\{\bm{Y} \bm{w}_{1}, \ldots, \bm{Y}\bm{w}_{s-1} \right\},
\end{aligned}$$
where $\bm{Y}$ is centred and $||\cdot||_2$ denotes the L2 norm.

---

### Forecastable Component (ForeC)

Forecastable components [@Goerg2013-yu] maximise \alert{forecastability} $\Omega(\cdot)$, finding linear combinations with \alert{most regular patterns}:
$$\begin{aligned}
\widehat{\mathbf{w}}_{s}=& \underset{\mathbf{w} \in \mathbb{R}^{k} \times 1}{\text{argmax} } \left(\Omega(\mathbf{Y}\mathbf{w} \right)), \quad s=1, \ldots, q \\
\text { subject to } \mathbf{Y}\mathbf{w}_{s}  & \perp\left\{\mathbf{Y} \mathbf{w}_{1}, \ldots, \mathbf{Y}\mathbf{w}_{s-1} \right\},
\end{aligned}$$
and
$$
\Omega\left(y_{t}\right)=1-H\left(y_{t}\right),
$$
where $H(y_t)$ is The Shannon entropy [@Shannon1948-bo] of the spectral density of $y_t$

## 1. Component: Nonlinear

### Manifold learning

Nonlinear dimension reduction that preserves the distances between points (relative locations of points) on a manifold

* Isomap, Laplacian Eigenmaps
* No back-transformation methods available


## 2. Forecast model

### Arbitrary choice of forecast models

* ARIMA
* Exponential smoothing
* Dynamic regression models
* Machine learning methods
* etc



## 3. Back-transformation

1. Construct a training set
    - Bootstrap to increase the sample size
    - Expanding window to cover more sample values
    - Redo Component Extraction and Component Forecast on each bootstrapped set
1. Fit a back-transformation model using the above as the sample

## Construct Training Set


<!-- Something similar to  -->
<!-- \includegraphics[width=\linewidth]{p_timeline} -->

```{r construct-train}
#| include: false

gen_rect <- function(xmin = x_start - rect_margin / 2,
                     ymax = y_top - sec_gap,
                     xmax = xmin + x_now - x_start + rect_margin,
                     ymin = ymax - rect_height,
                     fill = "#FAFAFA", colour = "black",
                     alpha = 1) {
  geom_rect(aes(xmin = xmin, ymin = ymin, xmax = xmax, ymax = ymax), fill = fill, colour = colour, alpha = alpha)
}

gen_rect_group <- function(xmin = x_start - rect_margin / 2,
                           ymax = y_top - sec_gap,
                           xmax = xmin + x_now - x_start + rect_margin,
                           ymin = ymax - rect_height, n = 1, gap = 0.03,
                           fill = "#FAFAFA", colour = "grey70",
                           alpha = 1) {
  mapply(
    function(xmin, ymax, xmax, ymin) {
      gen_rect(xmin, ymax, xmax = xmax, ymin = ymin, fill = fill, colour = colour, alpha = alpha)
    },
    xmin = seq(xmin, by = -gap, length.out = n),
    ymax = seq(ymax, by = -gap, length.out = n),
    xmax = seq(xmax, by = -gap, length.out = n),
    ymin = seq(ymin, by = -gap, length.out = n),
    SIMPLIFY = FALSE
  ) %>%
    rev()
}
gen_tile <- function(x = (x_start + x_now) / 2,
                     y = y_top - sec_gap - 0.5 * rect_height,
                     height = rect_height,
                     width = x_now - x_start + rect_margin,
                     fill = "#FAFAFA", colour = "black") {
  geom_tile(aes(x = x, y = y, height = height, width = width), fill = fill, colour = colour)
}

gen_tile_group <- function(x = (x_start + x_now) / 2,
                           y = y_top - sec_gap - 0.5 * rect_height,
                           height = rect_height,
                           width = x_now - x_start + rect_margin,
                           n = 1, gap = 0.03,
                           fill = "#FAFAFA", colour = "black") {
  mapply(
    function(x, y) {
      gen_tile(x, y, height = height, width = width, fill = fill, colour = colour)
    },
    x = seq(x, by = -gap, length.out = n),
    y = seq(y, by = -gap, length.out = n),
    SIMPLIFY = FALSE
  ) %>%
    rev()
}
curly <- function(x_left, x_right, y_top, y_bottom) {
  N <- 10
  Tilt <- 1
  # Long <- x_right-x_left
  Long <- 1
  # scale <- 0.1
  xcent <- (x_left + x_right) / 2
  ycent <- (y_top + y_bottom) / 2
  
  # y
  scale <- (y_top - y_bottom) / 2
  ymin <- scale / Tilt
  y2 <- ymin * Long
  i <- seq(0, pi / 2, length.out = N)
  x <- c(
    ymin * Tilt * (sin(i) - 1),
    seq(0, 0, length.out = 2),
    ymin * (Tilt * (1 - sin(rev(i)))),
    ymin * (Tilt * (1 - sin(i))),
    seq(0, 0, length.out = 2),
    ymin * Tilt * (sin(rev(i)) - 1)
  )
  y1 <- -x + ycent
  
  # x
  scale <- (xcent - x_left) / 3
  ymin <- scale / Tilt
  y2 <- ymin * Long
  y <- c(
    -cos(i) * ymin,
    c(0, y2),
    y2 + (cos(rev(i))) * ymin,
    y2 + (2 - cos(i)) * ymin,
    c(y2 + 2 * ymin, 2 * y2 + 2 * ymin),
    2 * y2 + 2 * ymin + cos(rev(i)) * ymin
  )
  x1 <- (y - ymin - y2) + xcent
  
  geom_path(aes(x = x1, y = y1), data = tibble(x1, y1))
}

#####
y_top <- 1
x_start <- 0
x_now <- 5
tick_h <- 0.02
x_lag <- tick_gap <- 1
rect_height <- 1 / 2
sec_gap <- 1.2
rect_margin <- 0.2
n_bootstrap <- n_lag <- 4
title_vjust <- -1.5

timeline_main <- tribble(
  ~x, ~xend, ~y, ~yend, ~label,
  x_start, x_now, y_top, y_top, "horizontal",
  seq(x_start, x_now, by = tick_gap),
  seq(x_start, x_now, by = tick_gap),
  y_top + tick_h,
  y_top, "tick"
) %>%
  unnest(cols = c(x, xend, y, yend))
title_main <- tribble(
  ~x, ~y, ~text,
  x_start, y_top, "Multivariate Series"
)
tick_label <- tribble(
  ~x, ~text,
  x_start, "0",
  x_now, "T",
  x_now - x_lag, "T-h",
  x_start + tick_gap, c("...")
) %>%
  unnest(everything()) %>%
  mutate(y = y_top) %>%
  pivot_longer(starts_with("y"), values_to = "y")
arrows <- tribble(
  ~x, ~y, ~xend, ~yend,
  (x_start + x_now) / 2, y_top - 0.5 * rect_height, (x_start + x_now) / 2, y_top - sec_gap - 0.5 * rect_height,
  (x_start + x_now - x_lag) / 2, y_top - sec_gap - 0.5 * rect_height, (x_start + x_now - x_lag) / 2, y_top - 2 * sec_gap - 0.5 * rect_height
)

curve1 <- tribble(
  ~x, ~y, ~xend, ~yend,
  x_now - x_lag, y_top - 2 * sec_gap - 0.5 * rect_height, x_now, y_top - 2 * sec_gap - 0.5 * rect_height,
)
curve2 <- tribble(
  ~x, ~y, ~xend, ~yend,
  x_now, y_top - 2 * sec_gap - 0.5 * rect_height, x_now, y_top - sec_gap - 0.5 * rect_height,
)


timeline_bootstrap <- timeline_main %>%
  mutate(
    y = y - sec_gap - 0.5 * rect_height,
    yend = yend - sec_gap - 0.5 * rect_height
  )
title_bootstrap <- tribble(
  ~x, ~y, ~text,
  x_start, y_top - sec_gap - 0.5 * rect_height, "Bootstrapped Series"
)

timeline_components <- timeline_main %>%
  mutate(
    y = y - 2 * sec_gap - 0.5 * rect_height,
    yend = yend - 2 * sec_gap - 0.5 * rect_height
  ) %>%
  add_row(
    x = x_start, xend = x_now - x_lag,
    y = y_top - 2 * sec_gap - 0.5 * rect_height,
    yend = y_top - 2 * sec_gap - 0.5 * rect_height,
    label = "horizontal_window"
  ) %>%
  mutate(linetype = ifelse(label == "horizontal", "dashed", "solid"))
title_components <- tribble(
  ~x, ~y, ~text,
  x_start, y_top - 2 * sec_gap - 0.5 * rect_height, "Components"
)
labels <- tribble(
  ~x, ~y, ~text,
  (x_start + x_now) / 2, y_top - 0.7 * sec_gap, "1. Bootstrap",
  (x_start + x_now - x_lag) / 2, y_top - 1.8 * sec_gap, "2. Estimate Components",
  (x_now + x_now - 1) / 2, y_top - 2 * sec_gap - rect_height, "3. Forecast Components",
  x_now, y_top - 1.8 * sec_gap, "4. Pair Observations",
)

pane_bc <- function(x_end_shift = 0, y_shift = 0, alpha = 1) {
  # bootstrap
  new_xend <- NULL
  list(
    gen_rect_group(
      xmin = x_start - rect_margin / 2,
      ymax = y_top - sec_gap + y_shift,
      xmax = x_start - rect_margin / 2 + x_now - x_start + rect_margin + x_end_shift,
      ymin = y_top - sec_gap - rect_height + y_shift,
      n = n_bootstrap,
      alpha = alpha
    ),
    geom_segment(aes(x = x, xend = xend, y = y, yend = yend),
                 alpha = alpha,
                 data = timeline_bootstrap %>%
                   mutate(
                     xend = ifelse(label == "horizontal",
                                   xend + x_end_shift, xend
                     ),
                     y = y + y_shift,
                     yend = yend + y_shift
                   ) %>%
                   filter(xend <= (new_xend <<- xend[label == "horizontal"]))
    ),
    geom_text(aes(x = x, y = y, label = text),
              data = mutate(title_bootstrap, y = y + y_shift),
              alpha = alpha,
              hjust = "left", vjust = title_vjust
    ),
    geom_text(aes(x = x, y = y - sec_gap - 0.5 * rect_height, label = text),
              data = tick_label %>%
                filter(x <= new_xend) %>%
                mutate(y = y + y_shift),
              alpha = alpha,
              vjust = -title_vjust
    ),
    # components
    gen_rect_group(
      xmin = x_start - rect_margin / 2,
      ymax = y_top - 2 * sec_gap + y_shift,
      xmax = x_start - rect_margin / 2 + x_now - x_start + rect_margin + x_end_shift,
      ymin = y_top - 2 * sec_gap - rect_height + y_shift,
      n = n_bootstrap,
      alpha = alpha
    ),
    geom_segment(aes(x = x, xend = xend, y = y, yend = yend, linetype = linetype),
                 alpha = alpha,
                 data = timeline_components %>%
                   mutate(
                     xend = ifelse(grepl("horizontal", label),
                                   xend + x_end_shift, xend
                     ),
                     y = y + y_shift,
                     yend = yend + y_shift
                   ) %>%
                   filter(xend <= (new_xend <<- xend[label == "horizontal"]))
    ),
    geom_text(aes(x = x, y = y, label = text),
              data = mutate(title_components, y = y + y_shift),
              alpha = alpha,
              hjust = "left", vjust = title_vjust
    ),
    geom_text(aes(x = x, y = y - 2 * sec_gap - 0.5 * rect_height, label = text),
              data = tick_label %>%
                filter(x <= new_xend) %>%
                mutate(y = y + y_shift),
              alpha = alpha, vjust = -title_vjust
    )
  )
}

p_backtransform <- ggplot() +
  # main
  geom_segment(aes(x = x, xend = xend, y = y - 0.5 * rect_height, yend = yend - 0.5 * rect_height),
               data = timeline_main
  ) +
  geom_text(aes(x = x, y = y - 0.5 * rect_height, label = text),
            data = title_main,
            hjust = "left", vjust = title_vjust
  ) +
  geom_text(aes(x = x, y = y - 0.5 * rect_height, label = text),
            data = tick_label, vjust = -title_vjust
  ) +
  # bootstrap and lags
  pane_bc(x_end_shift = -2, y_shift = 0.4, alpha = 0.2) +
  pane_bc(x_end_shift = -1, y_shift = 0.2, alpha = 0.4) +
  pane_bc() +
  scale_linetype_identity() +
  # arrows
  curly(x_start, x_now, y_top - 0.5 * rect_height - 0.15, y_top - 0.5 * rect_height - 0.3) +
  curly(
    x_start, x_now - x_lag, y_top - sec_gap - 0.5 * rect_height - 0.15,
    y_top - sec_gap - 0.5 * rect_height - 0.3
  ) +
  geom_segment(aes(x = x, y = y, xend = xend, yend = yend),
               data = arrows,
               arrow = arrow(length = unit(3, "mm")),
               position = position_attractsegment(
                 start_shave = 0.4, end_shave = 0.15, type_shave = "distance"
               )
  ) +
  geom_curve(
    aes(x = x, y = y - 0.1, xend = xend, yend = yend - 0.1),
    data = curve1,
    arrow = arrow(length = unit(3, "mm")),
    position = position_attractsegment(
      start_shave = 0.15, end_shave = 0.15, type_shave = "distance"
    )
  ) +
  geom_curve(
    aes(x = x + 0.3, y = y, xend = xend + 0.3, yend = yend),
    data = curve2,
    arrow = arrow(length = unit(3, "mm")),
    position = position_attractsegment(
      start_shave = 0.05, end_shave = 0.05, type_shave = "distance"
    )
  ) +
  geom_label(aes(x = x, y = y, label = text), data = labels) +
  geom_label(aes(x = x_now - x_lag / 2, y = y_top - sec_gap * 0.75, label = "5. Repeat at Lags"), colour = scales::alpha("black", 0.7)) +
  theme_void() +
  lims(
    x = c(-0.2, 5.8),
    y = c(-2, 0.85)
  )
p_backtransform
ggsave("plot/p_backtransform.pdf", p_backtransform,
       # height = unit(6, "cm"),
       # width = unit(9, "cm"))
       height = unit(6 / 1.4, "cm"),
       width = unit(10 / 1.4, "cm")
)
```

\begin{center}
\includegraphics[width=\linewidth]{plot/p_backtransform}
\end{center}


## Bootstrap

### @Bergmeir2016-yx

1. Box Cox Transformation
    - Stabilising variance
1. Seasonal and Trend decomposition using Loess (STL)
    - Separating series into trend, seasonality and the stationary remainder
1. Moving Block Bootstrap (MBB)
    - Bootstrapping stationary remainder
1. Adding back trend and seasonality. Inverting Box Cox transformation.

## STL Decomposition


```{r}
MelE <- visnights %>%
  filter(Region == "Melbourne") %>%
  pivot_wider(names_from = Region, values_from = Nights) %>%
  mutate(`Box Cox Transformed` = box_cox(`Melbourne`, guerrero(`Melbourne`))) %>%
  pivot_longer(-Month) %>%
  mutate(name = gsub("\\.", " ", name)) %>% 
  mutate(name = factor(name, levels = c("Melbourne", "Box Cox Transformed")))
```

```{r}
p_stl <- MelE %>%
  filter(name == "Box Cox Transformed") %>%
  model(STL(value ~ season(window = 21))) %>%
  components() %>%
  autoplot() +
  theme(plot.background = element_rect(fill = "#FAFAFA", colour = "#FAFAFA"))
ggsave("plot/p_stl.pdf", p_stl,
       height = unit(6 / 1.4, "cm"),
       width = unit(10 / 1.4, "cm")
)
```


\includegraphics[width=\linewidth]{plot/p_stl}


## MMB on the remainder


```{r}
#| include: false
x1 <- 1:3
x2 <- 7:9
block_size <- 3
colours <- c("#FE68B7", "#FF9628", "#502AFA", "#6EEF37")
block <- function(x) seq(x, length.out = block_size)
get_arrow <- function(x) {
  x %>% 
    group_by(g = as.integer(x>max(x1))) %>% 
    summarise(y = mean(y)) %>% 
    mutate(x = recode(g, 
                      `0` = max(x1)+0.5,
                      `1` = min(x2)-0.5
                      )) %>% 
    mutate(g = recode(g, 
                      `0` = "start",
                      `1` = "end"
                      )) %>% 
    pivot_longer(y:x) %>% 
    transmute(name = paste(name, g, sep = "_"), value) %>% 
    pivot_wider()
}

get_geom_arrow <- function(i){
    geom_segment(aes(x = x_start, y = y_start, xend = x_end, yend = y_end), 
               data = get_arrow(get(paste0("block", i))), colour = colours[[i]], 
               linewidth = 1,
               arrow = arrow(length = unit(5, "mm")),
               position = position_attractsegment(
                 start_shave = 0.25, end_shave = 0.25, 
                 type_shave = "distance"
               ))
}

tbl_left <- expand.grid(x = x1, y = 1:12)
tbl_right <- expand.grid(x = x2, y = 1:12)
block1 <- bind_rows(
  expand.grid(x = x1, y = block(9)),
expand.grid(x = x2, y = block(10))
) 
block2 <- bind_rows(
  expand.grid(x = x1, y = block(1)),
  expand.grid(x = x2, y = block(4))
) 
block3 <- bind_rows(
  expand.grid(x = x1, y = block(7)),
  expand.grid(x = x2, y = block(7))
) 
block4 <- bind_rows(
  expand.grid(x = x1, y = block(5)),
  expand.grid(x = x2, y = block(1))
) 

text_x <- tibble(x = c(x1, x2), y = 13, label = rep(paste0("Var", 1:3), 2))
text_y <- tibble(x = 0, y = 1:13, label = c(12:1, "Time"))


p_mmb <- ggplot() +
  geom_tile(aes(x=x, y = y), colour = "black", fill = "grey90", data = tbl_left) +
  geom_tile(aes(x=x, y = y), colour = "black", fill = "grey90", data = tbl_right) +
  geom_tile(aes(x = x, y = y), colour = colours[[4]], 
            data = block4, size =1.7, alpha = 0) +
  geom_tile(aes(x = x, y = y), colour = colours[[1]], 
            data = block1, size =1.5, alpha =0) +
  geom_tile(aes(x = x, y = y), colour = colours[[2]], 
            data = block2, size =1.2, alpha = 0) +
  geom_tile(aes(x = x, y = y), colour = colours[[3]], 
            data = block3, size =1, alpha = 0) +
  get_geom_arrow(1) +
  get_geom_arrow(2) +
  get_geom_arrow(3) +
  get_geom_arrow(4) +
  scale_y_continuous(breaks = 1:12) +
  geom_text(aes(x= x, y = y, label = label), data = text_x) +
  geom_text(aes(x= x, y = y, label = label), data = text_y) +
  theme_void()
ggsave("plot/p_mmb.pdf", p_mmb,
       height = unit(6 / 1.4, "cm"),
       width = unit(10 / 1.4, "cm")
)
```

\begin{center}
\includegraphics[width=\linewidth]{plot/p_mmb}
\end{center}

## Overview

```{r}
p_timeline_notation <- p_timeline +
  annotate("label", 
           x = x_future, y = y_top, label = "hat(bold(y))[T+h]", vjust = -.2, parse = TRUE, size = 5) +
  annotate("label", 
           x = x_future, y = y_bottom, label = "hat(bold(c))[T+h]", vjust = -.2, parse = TRUE, size = 5)


ggsave("plot/p_timeline_notation.pdf", p_timeline_notation,
       height = unit(6 / 1.4, "cm"),
       width = unit(10 / 1.4, "cm")
)
```

\begin{center}
\includegraphics[width=\linewidth]{plot/p_timeline_notation}
\end{center}

## Construct Training Set

```{r}

p_backtransform_notation <- p_backtransform +
  annotate("label", 
           x = x_now, 
           y = y_top - sec_gap - 0.5 * rect_height, 
           label = "bold(Y)^B", 
           vjust = -.5, parse = TRUE, size = 5) +
  annotate("label", 
           x = x_now, 
           y = y_top - 2 * sec_gap - 0.5 * rect_height, 
           label = "hat(bold(C))[h]^B", 
           vjust = -.3, parse = TRUE, size = 5)

ggsave("plot/p_backtransform_notation.pdf",
       p_backtransform_notation,
       height = unit(6 / 1.4, "cm"),
       width = unit(10 / 1.4, "cm")
)
```

\begin{center}
\includegraphics[width=\linewidth]{plot/p_backtransform_notation}
\end{center}


## Back-transformation Model

* $\hat{\bm{C}}^\mathsf{B}_h$: $h$-step-ahead forecasts of components from different bootstraps at different lags
* $\bm{Y}^\mathsf{B}$: the corresponding "real" values of the original series from bootstraps
* $\hat{\bm{c}}_{T+h}$: $h$-step-ahead forecasts of components of the original series
* $\hat{\bm{y}}_{T+h}$: $h$-step-ahead forecasts of the original series
* $\bm{S}$: collection of seasonal dummies corresponding to $\hat{\bm{C}}^\mathsf{B}_h$
* $\bm{s}_{T+h}$: seasonal dummies at time $T+h$
* $\bm{X} = \begin{bmatrix}\hat{\bm{C}}^\mathsf{B}_h & \bm{S}\end{bmatrix}$ 

## Back-transformation Model

$$
\hat{\bm{y}}_{T+h} = 
f(\hat{\bm{c}}_{T + h}, \bm{s}_{T+h})
$$ 

### Discounted Least Squares (DLS)
$$
\hat{\bm{y}}_{T+h} = 
\hat{\bm{B}}'
\begin{bmatrix}
\hat{\bm{c}}_{T + h} \\ \bm{s}_{T+h}
\end{bmatrix}
$$ 

$$
\hat{\bm{B}} = (\bm{X}'\bm{U}\bm{X})^{-1}\bm{X}'\bm{U}\bm{Y}^\mathsf{B}, 
$$





## Results

### Performance Measure (cross-validation)

$$
mRMSSE = \frac{1}{Mk}\sum^{M}_j\sum^{k}_i
\sqrt{\frac
{(y_{T-j+h,i}-\hat{y}_{T-j, h,i})^2}
{\frac{1}{T-j-\nu}\sum^{T-j}_{t={1+\nu}}(y_{ti} - y_{t-\nu, i})^2}}.
$$ 

### Multiple Comparisons with the Best (MCB)

Compare Average ranks of mRMSSE from independent simulation or cross-validations [@Koning2005-ch]

### Forecast model
Automatically selected ExponenTial Smoothing (ETS) model using AICc




## Australian tourism: PCA
```{r}
plot_mcb <- function(df){
  df %>%
    ggplot() +
    geom_rect(
      aes(xmin=l, xmax=u, fill = col),
      ymin=-Inf, ymax=Inf, alpha = 0.2,
      data = function(x) summarise(
        x,
        col = TRUE,
        l = l[[grep("Benchmark ETS", name)]],
        u = u[[grep("Benchmark ETS", name)]]))+
    geom_segment(aes(x = l, xend = u, yend = name, y = name)) +
    geom_point(aes(x = l, y = name), pch = "|", size = 2) +
    geom_point(aes(x = u, y = name), pch = "|", size = 2) +
    geom_point(aes(x = value, fill = col, y = name, pch = str_detect(name, "Bench") ), size = 3 ) +
    scale_shape_manual(values=c(21, 24)) +
    geom_label(
      data = function(x) {
        mutate(x, text = paste0(
          "Friedman test p-value ",
          ifelse(fpval<0.001,
                 " < 0.001", round(fpval, 3))))},
      aes(x = Inf, y = -Inf, label = text),
      vjust = "inward", hjust = "inward", size = 2.5,  label.size = NA) +
    labs(y = NULL, x = NULL) +
    # theme_minimal()+
    # facet_grid("h", scales = "free", labeller = label_both) +
    theme(legend.position = "none",
          text = element_text(size = 10),
          strip.text = element_text(size = 9),
          legend.margin=margin())
}
```


```{r}
mcb_pdata_top3 <- qs::qread("data/mcb_pdata_top3.qs")
mcb_pdata_top3 %>%
  arrange(value) %>%
  rename(h = .h) %>%
  mutate(name = factor(name,unique(name), ordered = TRUE)) %>%
  group_by(h) %>%
  plot_mcb() +
  facet_wrap("h", scales = "free",
             labeller = purrr::partial(label_both, sep = " = "))


```

## Conclusion

* Generic method to forecast using lower dimensional components with arbitrary choices of components and forecast models

* Robust to the number of components

* PCA and ISOMAP are competitive in short-term forecasts
* Laplacian Eigenmaps show better performance in longer-term forecasts



# Appendix

## Isomap

1. Construct Nearest Neighbour Graph
1. Estimate the Geodesic distances (distances along a manifold)
1. Apply Classical MDS
    - Input distances
    - Output coordinates in a lower dimension with similar distances

### Other Components

Laplacian Eigenmaps, etc





## Isomap

```{r}
#| include: false
set.seed(5)
h <- rep("reg", 10)
h[3] <- "point"
h[c(2, 6, 9)] <- "nn"
df <- tibble(X1 = runif(10), X2 = 1 - runif(10))


nn <- nn2(df)
k <- 3
dfe <- tibble(N1 = rep(1:10, k), N2 = as.vector(nn$nn.idx[, 2:(k + 1)]))
ng <- igraph::graph_from_data_frame(dfe, directed = FALSE) %>%
  igraph::simplify(remove.multiple = TRUE) 
set.seed(0)
graph_data <- layout.fruchterman.reingold(ng) %>% 
  as_tibble() %>% 
  `colnames<-`(c("x", "y")) %>% 
  mutate(label = sapply(ng, names))

dd <- dist(cbind(df$X1, df$X2)) %>% as.matrix()
wt <- rep(NA, length(E(ng)))
for (i in 1:length(E(ng))) {
  nds <- ends(ng, i) %>% as.numeric()
  wt[i] <- dd[nds[1], nds[2]]
}
# edge_attr(ng, "weight") <- wt


edge_data <- as_edgelist(ng) %>% 
  as_tibble() %>% 
  `colnames<-`(c("from", "to")) %>% 
  mutate(weight = wt) %>% 
  left_join(graph_data, by = c("from" = "label")) %>% 
  left_join(graph_data, by = c("to" = "label"), 
            suffix = c(".from", ".to")) %>% 
  mutate(colour = case_when(
    from %in% c(10, 4, 7, 8) & to %in% c(10, 4, 7, 8) ~ "blue",
    TRUE ~ "black"
  ))

scat1 <- df %>% ggplot(aes(
  x = X1, 
  y = X2, label = as.character(1:10))) +
  geom_point(size = 4) +
  geom_text_repel(size = 6) +
  theme(plot.background = element_rect(fill = "#FAFAFA", colour = "#FAFAFA"))

graph1 <- graph_data %>%   
  ggplot(aes(x = x, y = y)) +
  geom_segment(aes(x = x.from, y = y.from, 
                   xend = x.to, yend = y.to, 
                   linewidth = weight/10), 
               data = edge_data) +
  geom_point(size = bsize <- 8, colour = "black") +
  geom_point(size = bsize-1, colour = "lightgrey") +
  geom_text(aes(label = label)) + 
  theme_void() +
  scale_linewidth(range = c(0.2, 2)) +
  guides(linewidth = "none") +
  theme(plot.background = element_rect(fill = "#FAFAFA", colour = "#FAFAFA"))

df_sub <- slice(df,c(10,4,7,8))
scat2 <- ggplot(df, aes(x = X1, y = X2)) +
  geom_path(data = df_sub, mapping = aes(x = X1, y = X2), colour = "blue", size = 1) +
  geom_point(size = 4) +
  geom_text_repel(size = 6, label = as.character(1:10)) +
  theme(plot.background = element_rect(fill = "#FAFAFA", colour = "#FAFAFA"))

graph2 <- graph_data %>%   
  ggplot(aes(x = x, y = y)) +
  geom_segment(aes(x = x.from, y = y.from, 
                   xend = x.to, yend = y.to, 
                   linewidth = weight/10, 
                   colour = colour), 
               data = edge_data) +
  geom_point(size = bsize <- 8, colour = "black") +
  geom_point(size = bsize-1, colour = "lightgrey") +
  geom_text(aes(label = label)) + 
  theme_void() +
  scale_linewidth(range = c(0.2, 2)) +
  guides(linewidth = "none") +
  scale_colour_identity() +
  theme(plot.background = element_rect(fill = "#FAFAFA", colour = "#FAFAFA"))

ggsave("plot/p_isomap1.pdf", gridExtra::grid.arrange(scat1, graph1), 
       height = unit(6 / 1.4, "cm"),
       width = unit(10 / 1.4, "cm"))
ggsave("plot/p_isomap2.pdf", gridExtra::grid.arrange(scat2, graph2), 
       height = unit(6 / 1.4, "cm"),
       width = unit(10 / 1.4, "cm"))
```
<!-- Isomap, Laplacian Eigenmaps, etc -->

\begin{center}
\includegraphics[width=\linewidth]{plot/p_isomap1}
\end{center}

## Isomap

\begin{center}
\includegraphics[width=\linewidth]{plot/p_isomap2}
\end{center}


## Components Clustering

### Problem

* Some components do not have order. 
    - e.g. ForeCA
* Components from the bootstraps should provide similar information about the future

## Components Clustering: Before

```{r}
data_cluster <- qs::qread("data/clustering.qs")
data_after <- filter(data_cluster, name == "After clustering")
data_before <- filter(data_cluster, name == "Before clustering")
```


```{r}
p_cluster_before <- data_before %>%
  mutate(component = gsub("Component", "", component) %>% 
           factor(levels = 1:10)) %>% 
  ggplot(aes(x = Month, y = value)) +
  geom_line(aes(colour = as.factor(..id))) +
  facet_grid("component")+
  guides(colour = "none") +
  theme(axis.title = element_blank(), 
        plot.background = element_rect(fill = "#FAFAFA", colour = "#FAFAFA"), 
        axis.text.y = element_blank())
ggsave("plot/p_cluster_before.pdf", p_cluster_before,
       height = unit(6 / 1.4, "cm"),
       width = unit(10 / 1.4, "cm")
)
```

\begin{center}
\includegraphics[width=\linewidth]{plot/p_cluster_before}
\end{center}


## Components Clustering


### Solution: Feature-based clustering

1. Calculate features from each component
    - Highly comparative time-series analysis: @Fulcher2017-zl
    - @Talagala2023-yi 
1. Cluster the features
    - K-means with cannot-link constraints: COP kmeans @Wagstaff2001-vc 




## Components Clustering: After

```{r}
p_cluster_after <- data_after %>%
  mutate(component = gsub("Component", "", component) %>% 
           factor(levels = 1:10)) %>% 
  ggplot(aes(x = Month, y = value)) +
  geom_line(aes(colour = as.factor(..id))) +
  facet_grid("component")+
  guides(colour = "none") +
  theme(axis.title = element_blank(), 
        plot.background = element_rect(fill = "#FAFAFA", colour = "#FAFAFA"), 
        axis.text.y = element_blank())

ggsave("plot/p_cluster_after.pdf", p_cluster_after,
       height = unit(6 / 1.4, "cm"),
       width = unit(10 / 1.4, "cm")
)
```

\begin{center}
\includegraphics[width=\linewidth]{plot/p_cluster_after}
\end{center}


## Discounted Least Squares (DLS)

$$
u = \delta(1-\delta)^{\text{YearLag}}
$$ 

```{r}
exp_sm <- fable.components::exp_sm
p_dls <- tibble(x = 1:10) %>%
  mutate(
    `0.2` = exp_sm(x, 0.2),
    `0.4` = exp_sm(x, 0.4),
    `0.6` = exp_sm(x, 0.6),
  ) %>%
  mutate(across(-x, scale)) %>%
  pivot_longer(-x) %>%
  ggplot(aes(x = x, y = value, colour = name)) +
  geom_line() +
  geom_point() +
  # theme(axis.text.y = element_blank()) +
  labs(y = "Weights", 
       x = "Year Lag", 
       color = latex2exp::TeX(r"(\delta)")) +
  scale_x_continuous(breaks = c(1:10), 
                     labels = 9:0) +
  theme(plot.background = element_rect(fill = "#FAFAFA", colour = "#FAFAFA"))
ggsave("plot/p_dls.pdf", p_dls,
       height = unit(3.5/1.5, "cm"),
       width = unit(8/1.5, "cm")
)
```

\begin{center}
\includegraphics[width=\linewidth]{plot/p_dls}
\end{center}

## Box Cox Transformation

### Modified version of @Bickel1981-hv

$$
w_t  =
\begin{cases}
\log(y_t) & \text{if } \lambda=0;  \\
(\text{sign}(y_t)|y_t|^\lambda-1)/\lambda & \text{otherwise},
\end{cases}
$$

### Reverse transformation
$$
y_{t} =
\begin{cases}
\exp(w_{t}) & \text{if } \lambda=0;\\
\text{sign}(\lambda w_t+1)|\lambda w_t+1|^{1/\lambda} & \text{otherwise}.
\end{cases}
$$

## Box Cox Transformation

```{r}
# for(r in unique(visnights$Region)) {
#   print(r)
#   pp <- visnights %>%
#     filter(Region == r) %>%
#     mutate(`Box Cox Transformed` = box_cox(Nights, guerrero(Nights))) %>%
#     select(-Region) %>% 
#     pivot_longer(-Month) %>% 
#     ggplot(aes(x = Month, y = value)) +
#     geom_line() +
#     facet_grid("name", scales = "free")
#   print(pp)
#   readline()
# }
# "Australia.s.Golden.Outback"
# "Destination.Perth"
# "Fleurieu.Peninsula"
# "Gold.Coast"
# "Melbourne.East"
MelE <- visnights %>%
  filter(Region == "Melbourne.East") %>%
  pivot_wider(names_from = Region, values_from = Nights) %>%
  mutate(`Box Cox Transformed` = box_cox(`Melbourne.East`, guerrero(`Melbourne.East`))) %>%
  pivot_longer(-Month) %>%
  mutate(name = gsub("\\.", " ", name)) %>% 
  mutate(name = factor(name, levels = c("Melbourne East", "Box Cox Transformed")))

p_boxcox <- MelE %>%
  ggplot(aes(x = Month, y = value)) +
  geom_line() +
  facet_grid("name", scales = "free") +
  labs(x = "Time", y = "Value") +
  ggtitle("Visitor nights of Melbourne East: Box Cox Transformation") +
  theme(plot.background = element_rect(fill = "#FAFAFA", colour = "#FAFAFA"))
ggsave("plot/p_boxcox.pdf", p_boxcox,
       height = unit(6 / 1.4, "cm"),
       width = unit(10 / 1.4, "cm")
)
# Sys.getlocale()
```


\includegraphics[width=\linewidth]{plot/p_boxcox}

